import torch
import torch.nn as nn
import torchvision.datasets as datasets
from torch.utils.data import DataLoader, Subset
import matplotlib.pyplot as plt
from torchvision import transforms
import os # Import the os module
class VAE(nn.Module):
def init (self): super(). init (); self.encoder = nn.Sequential(nn.Linear(784, 400),
nn.ReLU(), nn.Linear(400, 40)); self.decoder = nn.Sequential(nn.Linear(20, 400), nn.ReLU(),
nn.Linear(400, 784), nn.Sigmoid())
def forward(self, x): h = self.encoder(x.view(-1, 784)); mu, logvar = h[:, :20], h[:, 20:]; std =
torch.exp(0.5 * logvar); z = mu + torch.randn_like(std) * std; return self.decoder(z), mu,
logvar
model = VAE().to(device:="cuda" if torch.cuda.is_available() else "cpu")
optimizer = torch.optim.Adam(model.parameters(), lr=0.001)
for epoch in range(10):
for data, _ in DataLoader(Subset(datasets.MNIST('./data', train=True, download=True,
transform=transforms.ToTensor()), [i for i, (_, label) in enumerate(datasets.MNIST('./data',
train=True, transform=transforms.ToTensor())) if label == 9]), batch_size=128, shufle=True):
data = data.to(device); recon, mu, logvar = model(data); loss =
nn.functional.binary_cross_entropy(recon, data.view(-1, 784), reduction='sum') - 0.5 *
torch.sum(1 + logvar - mu.pow(2) - logvar.exp()); optimizer.zero_grad(); loss.backward();
optimizer.step()
os.makedirs("synthetic_images", exist_ok=True)
model.eval(); [plt.imsave(f"synthetic_images/digit9_{i}.png", img, cmap='gray') for i, img in
enumerate(model.decoder(torch.randn(1000,
20).to(device)).cpu().detach().numpy().reshape(-1, 28, 28))]
try:
from google.colab import files; import shutil; shutil.make_archive("synthetic_images",
'zip', "synthetic_images"); files.download("synthetic_images.zip")
except:
print("Not in Colab. Images saved locally.")